# 消息通知平台服务 - 需求文档

## 文档版本信息

| 版本 | 日期 | 作者 | 说明 |
|------|------|------|------|
| v1.1 | 2025-10-24 | 需求分析师 | 第一期范围调整：聚焦邮件渠道；解决所有高优先级问题；完善数据库设计、接口设计和技术细节 |
| v1.0 | 2025-10-24 | 需求分析师 | 初始版本 |

---

## 1. 项目概述

### 1.1 项目背景
开发一个通用的消息通知平台服务，支持多种消息通知渠道（邮件、微信消息、微信公众号消息、短信等），作为独立服务部署，为后续业务系统提供统一的消息通知能力。

### 1.2 项目目标
- 提供统一的消息通知API接口，支持多种消息渠道
- 支持消息模板管理，提高消息发送的效率和一致性
- 支持定时/延迟发送功能，满足多样化的业务场景
- 提供管理后台，便于运营和维护
- 保证系统的高可用性和可扩展性
- 记录消息发送历史，便于追溯和分析

### 1.3 适用范围
- 初期：供自有业务系统接入使用
- 后期：具备对外提供服务的能力，支持第三方接入

### 1.4 预期效益
- 减少重复开发工作，提高开发效率
- 统一消息通知管理，提升运营效率
- 提供可靠的消息发送能力，提升用户体验
- 支持多渠道切换和容错，保证消息送达率

---

## 2. 需求分期规划

### 2.1 第一期（MVP - 最小可行产品）
**目标**：快速实现邮件通知核心功能，验证系统架构可行性

**核心功能**：
- ✅ 邮件发送功能（支持邮箱池轮询和自动切换）
- ✅ 消息模板管理（基础功能，支持版本管理）
- ✅ 消息发送历史记录
- ✅ 消息发送失败重试机制
- ✅ 消息去重机制（防止重复发送）
- ✅ RESTful API接口（含健康检查）
- ✅ 基础的消息队列集成（RabbitMQ + Celery）
- ✅ API认证和鉴权（JWT Token）
- ✅ 基础监控指标暴露

**预计开发周期**：2周

**说明**：第一期聚焦邮件渠道，快速验证整体架构。短信、微信等渠道将在第二期实现。

### 2.2 第二期（多渠道支持）
**目标**：扩展消息渠道，增加短信、微信支持

**核心功能**：
- 短信发送功能（阿里云渠道，支持多渠道容灾）
- 微信消息发送功能
- 微信公众号消息发送功能
- 定时/延迟发送功能
- 管理后台界面（消息查询、模板管理、统计分析）
- 消息统计分析功能
- 短信发送频率限制

**预计开发周期**：3-4周

### 2.3 第三期（高级特性）
**目标**：提升系统性能和运维能力

**核心功能**：
- API限流和防刷机制
- 监控告警功能
- 系统性能优化
- 多租户支持（为对外服务做准备）
- API Key管理
- 消息发送批量接口
- Webhook回调机制

**预计开发周期**：2-3周

---

## 3. 第一期（MVP）详细需求

> **重要说明**：第一期聚焦邮件通知渠道，目标是快速验证系统架构的可行性。短信、微信等渠道将在第二期实现。

### 3.1 功能需求

#### 3.1.1 邮件发送功能

**功能描述**：
- 支持通过SMTP协议发送邮件
- 支持文本格式和HTML格式邮件
- 支持邮件附件发送
- 支持邮箱池管理，当单个邮箱达到发送上限时自动切换

**详细需求**：
1. **邮箱池管理**
   - 支持配置多个SMTP邮箱账户
   - 每个邮箱账户记录当日发送数量
   - 支持配置每个邮箱的日发送上限（默认500封/天）
   - 达到上限后自动切换到下一个可用邮箱
   - 所有邮箱都达到上限时，返回失败并记录日志

2. **邮件发送**
   - 支持单个收件人和多个收件人（抄送、密送）
   - 支持邮件主题、正文（文本/HTML）
   - 支持附件上传（单个附件不超过10MB，总大小不超过20MB）
   - 支持自定义发件人名称

3. **发送状态反馈**
   - 发送成功：返回发送成功状态和消息ID
   - 发送失败：返回失败原因和错误码
   - 异步发送：立即返回任务ID，可通过任务ID查询发送状态

4. **邮箱池切换策略**（重要）
   - 按优先级选择邮箱（priority字段，数字越大优先级越高）
   - 同优先级下，按已发送数量升序选择（daily_sent_count最小的）
   - 发送成功后增加计数器：`daily_sent_count += 1`
   - 达到日限额后自动切换到下一个可用邮箱
   - 连续失败3次的邮箱自动标记为不可用（`is_active = false`）
   - 每天凌晨0点自动重置所有邮箱的发送计数

5. **邮箱池计数重置机制**（重要）
   - **实现方式**：使用PostgreSQL触发器自动重置
   - 当查询或更新邮箱记录时，自动检查`last_reset_date`
   - 如果不是当天，自动重置`daily_sent_count = 0`并更新`last_reset_date`
   - 备选方案：Celery定时任务（每天凌晨0点执行）

#### 3.1.2 邮件附件管理

**功能描述**：
- 支持邮件附件上传和发送
- 使用对象存储或本地文件系统存储附件

**详细需求**：
1. **附件上传**
   - 提供独立的附件上传接口：`POST /api/v1/attachments/upload`
   - 支持多文件上传（multipart/form-data）
   - 单个附件不超过10MB
   - 单封邮件附件总大小不超过20MB
   - 支持的文件类型：PDF、图片（jpg/png/gif）、Office文档、压缩包等

2. **附件存储**
   - **第一期**：使用本地文件系统存储（简化实现）
   - 存储路径：`/data/attachments/{date}/{uuid}.{ext}`
   - 文件保留7天后自动清理
   - **第二期及以后**：迁移到MinIO或阿里云OSS

3. **附件发送**
   - 发送邮件时传入附件ID，而不是Base64内容
   - 系统根据附件ID从存储中读取文件并发送
   - 发送后不立即删除，等待自动清理

#### 3.1.3 消息去重机制

**功能描述**：
- 防止网络抖动或客户端错误导致的重复消息发送
- 基于幂等键或内容指纹实现去重

**详细需求**：
1. **幂等键方式**（推荐）
   - 客户端在请求中提供`idempotency_key`（可选）
   - 如果提供，服务端检查Redis中是否存在该键
   - 存在则返回之前的结果，不重复发送
   - 不存在则正常发送，并将结果缓存到Redis（TTL=5分钟）

2. **内容指纹方式**（兜底）
   - 对于未提供幂等键的请求，生成内容指纹
   - 指纹算法：`SHA256(recipient + subject + content_hash + time_window)`
   - 时间窗口：5分钟（即5分钟内相同内容视为重复）
   - 使用Redis存储指纹，TTL=5分钟

3. **去重逻辑**
   ```python
   # 伪代码
   if idempotency_key:
       cached_result = redis.get(f"dedup:key:{idempotency_key}")
       if cached_result:
           return cached_result
   else:
       fingerprint = generate_fingerprint(message)
       if redis.exists(f"dedup:fp:{fingerprint}"):
           raise DuplicateMessageError("5分钟内重复消息")
   ```

#### 3.1.4 消息模板管理

**功能描述**：
- 提供统一的消息模板管理功能
- 第一期仅支持邮件模板，后续扩展到其他渠道
- 支持模板变量替换和版本管理

**详细需求**：
1. **模板CRUD操作**
   - 创建模板：输入模板名称、模板类型（第一期固定为email）、主题、内容
   - 修改模板：支持修改模板内容和变量
   - 删除模板：软删除（设置deleted_at），保留历史记录
   - 查询模板：支持按模板名称、类型查询，支持分页（page, page_size）

2. **模板内容**
   - 支持变量占位符：使用Jinja2语法，如 `{{username}}`, `{{code}}` 等
   - 支持HTML富文本内容
   - 支持条件判断：`{% if variable %}...{% endif %}`
   - 支持循环：`{% for item in items %}...{% endfor %}`
   - 支持模板预览功能（提供测试数据渲染模板）

3. **模板版本管理**（重要）
   - 每次修改模板时：
     - 在`message_template_history`表中保存当前版本
     - 主表`message_templates`的`version`字段+1
     - 记录修改人和修改说明
   - 历史版本查询：`GET /api/v1/templates/{id}/history`
   - 版本回滚：`POST /api/v1/templates/{id}/rollback` (body: `{version: 2}`)
   - 所有已发送的消息记录关联的是模板ID+版本号

#### 3.1.5 消息发送历史记录

**功能描述**：
- 记录所有消息发送的历史记录
- 支持历史记录查询和统计

**详细需求**：
1. **记录内容**
   - 消息ID（唯一标识，格式：`msg_{timestamp}_{random}`）
   - 消息类型（第一期固定为email）
   - 接收人信息（邮箱地址）
   - 邮件主题
   - 消息内容（存储渲染后的完整HTML内容）
   - 模板ID和模板变量（如果使用了模板）
   - 模板版本号（记录使用的模板版本）
   - 发送状态（pending/sending/success/failed）
   - 使用的邮箱账户ID（sender_info JSONB字段）
   - 发送时间（sent_at）
   - 失败原因（error_message）
   - 重试次数（retry_count）
   - 幂等键（idempotency_key，如果客户端提供）

2. **查询功能**
   - 按消息ID精确查询：`GET /api/v1/messages/{message_id}`
   - 按条件查询（支持分页）：`GET /api/v1/messages`
     - 查询参数：recipient, status, start_date, end_date, page, page_size
   - 批量查询：`POST /api/v1/messages/batch/query` (body: `{message_ids: []}`)

3. **数据保留策略**
   - 详细记录保留30天（通过定时任务归档）
   - 30天后只保留统计数据（转移到归档表）
   - 失败记录保留90天（便于问题排查）
   - 提供数据归档接口（手动触发）

#### 3.1.6 消息发送失败重试机制

**功能描述**：
- 对发送失败的消息自动进行重试
- 支持配置重试策略

**详细需求**：
1. **重试策略**
   - 最大重试次数：3次
   - 重试间隔：第1次失败后1分钟重试，第2次失败后5分钟重试，第3次失败后10分钟重试
   - 支持指数退避策略

2. **重试条件**
   - 网络错误：进行重试
   - 服务商返回临时错误：进行重试
   - 参数错误：不重试，直接标记为失败
   - 余额不足：不重试，触发告警

3. **重试记录**
   - 记录每次重试的时间和结果（存储在retry_logs JSONB字段）
   - 达到最大重试次数后标记为最终失败（status=failed）
   - 最终失败的消息记录到死信队列
   - 失败消息记录包含详细的错误堆栈（便于排查）

4. **重试实现**
   - 使用Celery的retry机制
   - 失败消息自动重新入队到retry队列
   - 延迟执行（countdown参数）

#### 3.1.7 消息队列集成

**功能描述**：
- 使用消息队列解耦消息发送请求和实际发送过程
- 提高系统吞吐量和可靠性

**详细需求**：
1. **队列设计**
   - 发送队列：存储待发送的消息
   - 重试队列：存储需要重试的失败消息
   - 死信队列：存储最终失败的消息

2. **消息队列选型**
   - 推荐使用RabbitMQ或Redis
   - 支持消息持久化
   - 支持消息确认机制

3. **消费者设计**
   - 支持多消费者并发消费
   - 消费失败后消息重新入队
   - 支持消费者数量动态调整（通过Celery的autoscale）
   - Worker监控：使用Flower监控Celery任务执行情况

#### 3.1.8 API认证和鉴权

**功能描述**：
- 提供基于JWT Token的API认证机制
- 支持API Key管理

**详细需求**：
1. **API Key管理**
   - 提供API Key创建接口（需要管理员权限）
   - API Key格式：`noti_{random_32_chars}`
   - API Secret使用bcrypt哈希存储
   - 支持设置过期时间（expire_at）
   - 支持禁用/启用API Key

2. **JWT Token认证流程**
   - 客户端使用API Key + API Secret获取Token
   - 接口：`POST /api/v1/auth/token`
     ```json
     {
       "api_key": "noti_xxx",
       "api_secret": "xxx"
     }
     ```
   - 返回JWT Token（有效期1小时）
   - 后续请求携带Token：`Authorization: Bearer {token}`

3. **Token刷新**
   - 提供Token刷新接口：`POST /api/v1/auth/refresh`
   - 在Token过期前5分钟可以刷新
   - 刷新后返回新Token，旧Token失效

4. **权限控制**
   - 第一期暂不实现细粒度权限
   - 所有通过认证的客户端拥有相同权限
   - 第二期实现基于角色的权限控制（RBAC）

#### 3.1.9 基础监控指标暴露

**功能描述**：
- 暴露Prometheus格式的监控指标
- 提供系统健康检查接口

**详细需求**：
1. **健康检查接口**
   - `GET /health` - 简单健康检查（返回200即可）
   - `GET /health/ready` - 就绪检查（检查数据库、Redis、RabbitMQ连接）
   - `GET /health/live` - 存活检查（检查进程是否存活）

2. **监控指标接口**
   - `GET /metrics` - Prometheus格式指标
   - 使用`prometheus_client`库实现

3. **核心监控指标**
   - **API指标**：
     - `http_requests_total`：HTTP请求总数（按path、method、status分类）
     - `http_request_duration_seconds`：请求响应时间（直方图）
   - **消息指标**：
     - `messages_sent_total`：消息发送总数（按type、status分类）
     - `messages_send_duration_seconds`：消息发送耗时
     - `email_pool_available_accounts`：可用邮箱账户数
     - `email_pool_daily_sent`：各邮箱当日发送数
   - **队列指标**：
     - `queue_length`：队列长度（按队列名分类）
     - `celery_tasks_total`：Celery任务总数（按状态分类）
   - **基础设施指标**：
     - `db_connections_active`：活跃数据库连接数
     - `redis_memory_usage_bytes`：Redis内存使用

### 3.2 非功能需求

#### 3.2.1 性能需求
- API接口响应时间：P95 < 200ms（不含实际发送时间）
- 消息入队时间：< 100ms
- 支持并发：至少支持50个并发请求
- 消息发送吞吐量：至少100条/分钟

#### 3.2.2 可用性需求
- 系统可用性目标：99%（第一期）
- 数据库连接池配置：最小连接数5，最大连接数20
- 接口超时时间：30秒
- 提供详细的错误日志和异常处理机制

#### 3.2.3 安全性需求
- **认证加密**：
  - 所有API接口需要进行JWT Token认证
  - JWT使用HS256算法签名
  - Token有效期1小时，支持刷新
  
- **数据加密**：
  - 敏感信息加密算法：AES-256-GCM
  - SMTP密码、API Secret等敏感字段加密存储
  - 加密密钥通过环境变量配置，不提交到代码仓库
  - 数据库连接使用SSL/TLS加密
  
- **传输加密**：
  - 生产环境强制使用HTTPS（TLS 1.2+）
  - HTTP请求自动重定向到HTTPS
  
- **安全防护**：
  - 使用SQLAlchemy ORM防止SQL注入
  - 用户输入进行HTML转义防止XSS攻击
  - API限流防止暴力破解（第三期实现）
  - 敏感日志信息脱敏（邮箱地址、密码等）

#### 3.2.4 可维护性需求

1. **代码规范**
   - 遵循PEP8代码规范
   - 使用Black格式化代码
   - 使用Pylint/Flake8进行代码检查
   - 代码注释覆盖率不低于30%
   - 核心函数必须有Docstring

2. **测试要求**
   - 单元测试覆盖率不低于60%
   - 核心功能（邮箱池、模板渲染、认证）必须有测试
   - 使用pytest框架编写测试
   - 集成测试覆盖主要业务流程

3. **文档要求**
   - 提供完整的API文档（Swagger/OpenAPI自动生成）
   - 提供部署文档和运维手册
   - 提供开发环境搭建文档
   - 关键业务流程图和时序图

4. **日志规范**（重要）
   - **日志格式**：JSON格式，便于日志采集
     ```json
     {
       "timestamp": "2025-10-24T10:00:00.000Z",
       "level": "INFO",
       "request_id": "req_xyz789",
       "service": "notification-api",
       "module": "email_service",
       "message": "邮件发送成功",
       "context": {
         "message_id": "msg_20251024_abc123",
         "recipient": "u***@example.com",  // 脱敏
         "duration_ms": 150
       }
     }
     ```
   
   - **日志级别使用规范**：
     - `DEBUG`：详细的调试信息（生产环境关闭）
     - `INFO`：正常的业务流程信息（邮件发送成功、邮箱切换等）
     - `WARNING`：警告信息（邮箱达到上限、重试次数较多等）
     - `ERROR`：错误信息（发送失败、第三方服务异常）
     - `CRITICAL`：严重错误（数据库连接失败、Redis连接失败）
   
   - **Request ID追踪**：
     - 每个API请求生成唯一的Request ID
     - Request ID贯穿整个请求链路（API -> Queue -> Worker）
     - 在响应Header中返回：`X-Request-ID: req_xyz789`
   
   - **敏感信息脱敏**：
     - 邮箱地址：`user@example.com` -> `u***@example.com`
     - 密码：不记录到日志
     - Token：只记录前8位
   
   - **日志存储**：
     - 使用loguru库进行日志管理
     - 日志按天切割，保留30天
     - 错误日志单独存储，保留90天

### 3.3 技术架构

#### 3.3.1 技术栈
- **开发语言**：Python 3.10+
- **Web框架**：FastAPI（高性能、自动生成API文档）
- **数据库**：PostgreSQL 14+
- **ORM**：SQLAlchemy
- **消息队列**：RabbitMQ 或 Redis
- **缓存**：Redis
- **任务调度**：Celery
- **容器化**：Docker + Docker Compose
- **日志**：Python logging + ELK（可选）

#### 3.3.2 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                          客户端应用                           │
└──────────────────────────┬──────────────────────────────────┘
                           │ HTTP/HTTPS
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    API Gateway (FastAPI)                     │
│  - 身份认证    - 参数验证    - 限流控制    - 接口文档       │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                      业务逻辑层 (Service)                    │
│  - 消息服务    - 模板服务    - 历史记录服务                 │
└──────────────┬────────────────────────┬─────────────────────┘
               │                        │
               ▼                        ▼
┌─────────────────────┐    ┌──────────────────────────────────┐
│   消息队列(RabbitMQ)  │    │      数据库(PostgreSQL)          │
│  - 发送队列          │    │  - 消息记录表                    │
│  - 重试队列          │    │  - 模板表                        │
│  - 死信队列          │    │  - 邮箱账户表                    │
└──────────┬──────────┘    │  - 短信配置表                    │
           │               └──────────────────────────────────┘
           ▼
┌─────────────────────────────────────────────────────────────┐
│              消息消费者 (Celery Worker)                       │
│  - 邮件发送Worker    - 短信发送Worker    - 重试Worker        │
└──────────────┬──────────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────────┐
│                    第三方服务集成层                           │
│  - SMTP服务(邮箱池)    - 阿里云短信SDK                       │
└─────────────────────────────────────────────────────────────┘
```

#### 3.3.3 数据库设计

> **说明**：第一期数据库设计聚焦邮件功能，短信、微信相关表将在第二期添加。

**消息记录表 (message_records)**
```sql
CREATE TABLE message_records (
    id BIGSERIAL PRIMARY KEY,
    message_id VARCHAR(64) UNIQUE NOT NULL,           -- 消息唯一ID
    message_type VARCHAR(20) NOT NULL DEFAULT 'email', -- 消息类型（第一期固定为email）
    template_id BIGINT,                               -- 模板ID（可为空）
    template_version INT,                             -- 模板版本号
    recipient VARCHAR(255) NOT NULL,                  -- 接收人（邮箱地址）
    subject VARCHAR(255),                             -- 邮件主题
    content TEXT,                                     -- 消息内容（渲染后的完整内容）
    template_vars JSONB,                              -- 模板变量（JSON格式）
    status VARCHAR(20) NOT NULL DEFAULT 'pending',    -- 状态: pending/sending/success/failed
    retry_count INT DEFAULT 0,                        -- 重试次数
    error_message TEXT,                               -- 错误信息
    retry_logs JSONB,                                 -- 重试日志
    sender_info JSONB,                                -- 发送者信息（邮箱账户ID等）
    idempotency_key VARCHAR(128),                     -- 幂等键
    request_id VARCHAR(64),                           -- 请求ID（追踪用）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sent_at TIMESTAMP,                                -- 实际发送时间
    
    -- 索引
    INDEX idx_message_id (message_id),
    INDEX idx_recipient (recipient),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    INDEX idx_idempotency_key (idempotency_key),
    
    -- 外键约束
    CONSTRAINT fk_template 
        FOREIGN KEY (template_id) 
        REFERENCES message_templates(id) 
        ON DELETE SET NULL
);

-- 添加注释
COMMENT ON TABLE message_records IS '消息发送记录表';
COMMENT ON COLUMN message_records.idempotency_key IS '客户端提供的幂等键，用于防止重复发送';
COMMENT ON COLUMN message_records.retry_logs IS 'JSON数组，记录每次重试的时间和结果';
```

**消息模板表 (message_templates)**
```sql
CREATE TABLE message_templates (
    id BIGSERIAL PRIMARY KEY,
    template_name VARCHAR(100) UNIQUE NOT NULL,       -- 模板名称
    template_type VARCHAR(20) NOT NULL DEFAULT 'email', -- 模板类型（第一期固定为email）
    subject VARCHAR(255),                             -- 邮件主题模板
    content TEXT NOT NULL,                            -- 内容模板（Jinja2语法）
    variables JSONB,                                  -- 变量列表 ["var1", "var2"]
    version INT DEFAULT 1,                            -- 当前版本号
    is_active BOOLEAN DEFAULT true,                   -- 是否启用
    description TEXT,                                 -- 模板描述
    created_by VARCHAR(100),                          -- 创建人
    updated_by VARCHAR(100),                          -- 最后修改人
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,                             -- 软删除时间
    
    -- 索引
    INDEX idx_template_name (template_name),
    INDEX idx_template_type (template_type),
    INDEX idx_is_active (is_active),
    INDEX idx_deleted_at (deleted_at)
);

-- 添加注释
COMMENT ON TABLE message_templates IS '消息模板表';
COMMENT ON COLUMN message_templates.content IS '使用Jinja2模板语法，如: Hello {{username}}';
COMMENT ON COLUMN message_templates.variables IS 'JSON数组，定义模板中使用的变量';
```

**消息模板历史表 (message_template_history)**
```sql
CREATE TABLE message_template_history (
    id BIGSERIAL PRIMARY KEY,
    template_id BIGINT NOT NULL,                      -- 关联的模板ID
    version INT NOT NULL,                             -- 版本号
    template_name VARCHAR(100) NOT NULL,
    template_type VARCHAR(20) NOT NULL,
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    change_description TEXT,                          -- 修改说明
    created_by VARCHAR(100),                          -- 修改人
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_template_id (template_id),
    INDEX idx_version (template_id, version),
    
    -- 唯一约束
    UNIQUE (template_id, version),
    
    -- 外键约束
    CONSTRAINT fk_template_history 
        FOREIGN KEY (template_id) 
        REFERENCES message_templates(id) 
        ON DELETE CASCADE
);

-- 添加注释
COMMENT ON TABLE message_template_history IS '模板历史版本表，用于版本管理和回滚';
```

**邮箱账户表 (email_accounts)**
```sql
CREATE TABLE email_accounts (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,               -- 邮箱地址
    smtp_host VARCHAR(255) NOT NULL,                  -- SMTP服务器
    smtp_port INT NOT NULL,                           -- SMTP端口
    smtp_username VARCHAR(255) NOT NULL,              -- SMTP用户名
    smtp_password VARCHAR(255) NOT NULL,              -- SMTP密码（AES-256-GCM加密存储）
    display_name VARCHAR(100),                        -- 发件人显示名称
    daily_limit INT DEFAULT 500,                      -- 日发送上限
    daily_sent_count INT DEFAULT 0,                   -- 当日已发送数量
    last_reset_date DATE DEFAULT CURRENT_DATE,        -- 上次重置日期
    is_active BOOLEAN DEFAULT true,                   -- 是否启用
    priority INT DEFAULT 0,                           -- 优先级（数字越大优先级越高）
    failure_count INT DEFAULT 0,                      -- 连续失败次数（超过3次自动禁用）
    last_failure_at TIMESTAMP,                        -- 最后失败时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_email (email),
    INDEX idx_is_active (is_active),
    INDEX idx_priority (priority DESC, daily_sent_count ASC)
);

-- 添加注释
COMMENT ON TABLE email_accounts IS '邮箱账户池';
COMMENT ON COLUMN email_accounts.priority IS '优先级，数字越大越优先使用';
COMMENT ON COLUMN email_accounts.failure_count IS '连续失败次数，达到3次自动禁用';

-- 创建自动重置日发送计数的触发器（重要）
CREATE OR REPLACE FUNCTION reset_daily_count_if_needed()
RETURNS TRIGGER AS $$
BEGIN
    -- 如果不是当天，自动重置计数
    IF NEW.last_reset_date < CURRENT_DATE THEN
        NEW.daily_sent_count = 0;
        NEW.last_reset_date = CURRENT_DATE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_reset_daily_count
BEFORE SELECT OR UPDATE ON email_accounts
FOR EACH ROW
EXECUTE FUNCTION reset_daily_count_if_needed();

-- 备注：BEFORE SELECT 触发器在PostgreSQL 9.5+支持
-- 如果版本较低，可以使用Celery定时任务替代
```

**邮件附件表 (email_attachments)**
```sql
CREATE TABLE email_attachments (
    id BIGSERIAL PRIMARY KEY,
    attachment_id VARCHAR(64) UNIQUE NOT NULL,        -- 附件唯一ID
    filename VARCHAR(255) NOT NULL,                   -- 原始文件名
    file_path VARCHAR(500) NOT NULL,                  -- 存储路径
    file_size BIGINT NOT NULL,                        -- 文件大小（字节）
    mime_type VARCHAR(100),                           -- MIME类型
    uploaded_by VARCHAR(100),                         -- 上传者
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,                             -- 过期时间（7天后）
    
    -- 索引
    INDEX idx_attachment_id (attachment_id),
    INDEX idx_expires_at (expires_at)
);

-- 添加注释
COMMENT ON TABLE email_attachments IS '邮件附件表';
COMMENT ON COLUMN email_attachments.expires_at IS '附件过期时间，过期后自动清理';
```

**API密钥表 (api_keys)**
```sql
CREATE TABLE api_keys (
    id BIGSERIAL PRIMARY KEY,
    key_name VARCHAR(100) NOT NULL,                   -- 密钥名称
    api_key VARCHAR(64) UNIQUE NOT NULL,              -- API Key (格式: noti_xxx)
    api_secret_hash VARCHAR(255) NOT NULL,            -- API Secret哈希值（bcrypt）
    is_active BOOLEAN DEFAULT true,                   -- 是否启用
    expire_at TIMESTAMP,                              -- 过期时间
    last_used_at TIMESTAMP,                           -- 最后使用时间
    usage_count BIGINT DEFAULT 0,                     -- 使用次数
    description TEXT,                                 -- 描述信息
    created_by VARCHAR(100),                          -- 创建人
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_api_key (api_key),
    INDEX idx_is_active (is_active)
);

-- 添加注释
COMMENT ON TABLE api_keys IS 'API密钥表，用于客户端认证';
COMMENT ON COLUMN api_keys.api_secret_hash IS 'API Secret的bcrypt哈希值，不存储明文';
```

**数据库初始化脚本说明**

第一期需要创建的表：
1. `message_records` - 消息记录表
2. `message_templates` - 消息模板表  
3. `message_template_history` - 模板历史表
4. `email_accounts` - 邮箱账户表
5. `email_attachments` - 邮件附件表
6. `api_keys` - API密钥表

触发器：
- `reset_daily_count_if_needed()` - 自动重置邮箱日发送计数

第二期再添加：
- `sms_configs` - 短信配置表
- `sms_templates` - 短信模板表
- `wechat_configs` - 微信配置表
- `scheduled_tasks` - 定时任务表
- 等等

### 3.4 接口设计

#### 3.4.1 通用响应格式

**成功响应**
```json
{
    "code": 0,
    "message": "success",
    "data": {
        // 业务数据
    },
    "request_id": "uuid"
}
```

**失败响应**
```json
{
    "code": 错误码,
    "message": "错误描述",
    "data": null,
    "request_id": "uuid"
}
```

#### 3.4.2 身份认证

**认证流程**：
1. 客户端使用API Key和API Secret获取JWT Token
2. 后续请求携带JWT Token进行认证

**认证接口**：`POST /api/v1/auth/token`

**请求示例**：
```json
{
    "api_key": "noti_abc123def456",
    "api_secret": "secret_xyz789"
}
```

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "bearer",
        "expires_in": 3600
    },
    "request_id": "req_abc123"
}
```

**后续请求携带Token**：
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 3.4.3 健康检查接口

**简单健康检查**：`GET /health`
```json
{
    "status": "healthy"
}
```

**就绪检查**：`GET /health/ready`
```json
{
    "status": "ready",
    "components": {
        "database": "ok",
        "redis": "ok",
        "rabbitmq": "ok"
    },
    "timestamp": "2025-10-24T10:00:00Z"
}
```

**存活检查**：`GET /health/live`
```json
{
    "status": "alive"
}
```

#### 3.4.4 附件上传接口

**接口地址**：`POST /api/v1/attachments/upload`

**请求类型**：`multipart/form-data`

**请求参数**：
- `file`: 文件（支持多个）
- `uploaded_by`: 上传者（可选）

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": [
        {
            "attachment_id": "att_20251024_abc123",
            "filename": "report.pdf",
            "file_size": 1024000,
            "mime_type": "application/pdf",
            "expires_at": "2025-10-31T10:00:00Z"
        }
    ],
    "request_id": "req_xyz789"
}
```

#### 3.4.5 邮件发送接口

**接口地址**：`POST /api/v1/messages/email/send`

**重要说明**：
- `content` 和 `template_id` 二选一，不能同时提供
- 使用模板时，必须提供 `template_id` 和 `template_vars`
- 直接发送时，必须提供 `subject` 和 `content`

**请求参数（直接发送模式）**：
```json
{
    "to": "receiver@example.com",                    // 必填，收件人邮箱
    "cc": ["cc1@example.com", "cc2@example.com"],   // 可选，抄送
    "bcc": ["bcc@example.com"],                      // 可选，密送
    "subject": "测试邮件",                           // 必填，邮件主题
    "content": "<h1>这是测试邮件内容</h1>",          // 必填，邮件内容（HTML或文本）
    "content_type": "html",                          // 可选，内容类型: html/text，默认html
    "attachment_ids": ["att_xxx", "att_yyy"],       // 可选，附件ID列表（通过附件上传接口获取）
    "idempotency_key": "unique-key-123",            // 可选，幂等键（防止重复发送）
    "async": true                                    // 可选，是否异步发送，默认true
}
```

**请求参数（模板发送模式）**：
```json
{
    "to": "receiver@example.com",
    "template_id": 1,                                // 必填，模板ID
    "template_vars": {                               // 必填，模板变量
        "username": "张三",
        "code": "123456"
    },
    "attachment_ids": [],                            // 可选，附件ID列表
    "idempotency_key": "unique-key-456",            // 可选，幂等键
    "async": true
}
```

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "message_id": "msg_20251024_abc123",
        "status": "pending"
    },
    "request_id": "req_xyz789"
}
```

#### 3.4.6 消息状态查询接口

**接口地址**：`GET /api/v1/messages/{message_id}`

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "message_id": "msg_20251024_abc123",
        "message_type": "email",
        "recipient": "receiver@example.com",
        "status": "success",
        "retry_count": 0,
        "created_at": "2025-10-24 10:00:00",
        "sent_at": "2025-10-24 10:00:05"
    },
    "request_id": "req_xyz789"
}
```

#### 3.4.7 消息批量查询接口

**接口地址**：`POST /api/v1/messages/batch/query`

**请求参数**：
```json
{
    "message_ids": [
        "msg_20251024_abc123",
        "msg_20251024_abc124",
        "msg_20251024_abc125"
    ]
}
```

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": [
        {
            "message_id": "msg_20251024_abc123",
            "status": "success",
            "recipient": "user1@example.com",
            "sent_at": "2025-10-24 10:00:05"
        },
        {
            "message_id": "msg_20251024_abc124",
            "status": "failed",
            "recipient": "user2@example.com",
            "error_message": "SMTP连接超时"
        }
    ],
    "request_id": "req_xyz789"
}
```

#### 3.4.8 消息历史查询接口

**接口地址**：`GET /api/v1/messages`

**查询参数**：
- `recipient`: 接收人（可选）
- `status`: 发送状态（可选）
- `start_date`: 开始日期（可选）
- `end_date`: 结束日期（可选）
- `page`: 页码，默认1
- `page_size`: 每页数量，默认20

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "total": 100,
        "page": 1,
        "page_size": 20,
        "records": [
            {
                "message_id": "msg_20251024_abc123",
                "message_type": "email",
                "recipient": "receiver@example.com",
                "subject": "测试邮件",
                "status": "success",
                "created_at": "2025-10-24 10:00:00",
                "sent_at": "2025-10-24 10:00:05"
            }
        ]
    },
    "request_id": "req_xyz789"
}
```

#### 3.4.9 模板管理接口

**创建模板**：`POST /api/v1/templates`

**请求参数**：
```json
{
    "template_name": "验证码邮件",
    "template_type": "email",
    "subject": "您的验证码",
    "content": "<div><p>尊敬的{{username}}，您好！</p><p>您的验证码是：<strong>{{code}}</strong></p><p>有效期{{expire_minutes}}分钟。</p></div>",
    "variables": ["username", "code", "expire_minutes"],
    "description": "用户注册验证码邮件模板",
    "created_by": "admin"
}
```

**查询模板列表**：`GET /api/v1/templates?page=1&page_size=20&template_type=email`

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "total": 10,
        "page": 1,
        "page_size": 20,
        "records": [
            {
                "id": 1,
                "template_name": "验证码邮件",
                "template_type": "email",
                "version": 2,
                "is_active": true,
                "description": "用户注册验证码邮件模板",
                "created_at": "2025-10-24 10:00:00"
            }
        ]
    }
}
```

**查询单个模板**：`GET /api/v1/templates/{template_id}`

**查询模板历史版本**：`GET /api/v1/templates/{template_id}/history`

**更新模板**：`PUT /api/v1/templates/{template_id}`

**请求参数**：
```json
{
    "subject": "【验证码】您的验证码",
    "content": "新的模板内容...",
    "change_description": "修改邮件主题，增加品牌标识",
    "updated_by": "admin"
}
```

**模板回滚**：`POST /api/v1/templates/{template_id}/rollback`

**请求参数**：
```json
{
    "version": 1,
    "change_description": "回滚到版本1",
    "updated_by": "admin"
}
```

**删除模板（软删除）**：`DELETE /api/v1/templates/{template_id}`

**模板预览**：`POST /api/v1/templates/preview`

**请求参数**：
```json
{
    "template_id": 1,
    "template_vars": {
        "username": "张三",
        "code": "123456",
        "expire_minutes": "5"
    }
}
```

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "subject": "您的验证码",
        "content": "<div><p>尊敬的张三，您好！</p><p>您的验证码是：<strong>123456</strong></p><p>有效期5分钟。</p></div>"
    }
}
```

### 3.5 部署方案

#### 3.5.1 Docker Compose配置

**项目目录结构**：
```
notification-platform/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI应用入口
│   ├── config.py               # 配置文件
│   ├── models/                 # 数据库模型
│   ├── schemas/                # Pydantic模型
│   ├── services/               # 业务逻辑
│   ├── api/                    # API路由
│   ├── tasks/                  # Celery任务
│   └── utils/                  # 工具函数
├── tests/                      # 测试代码
├── docker/
│   ├── Dockerfile
│   └── docker-compose.yml
├── requirements.txt
├── README.md
└── .env                        # 环境变量配置
```

**docker-compose.yml示例**：
```yaml
version: '3.8'

services:
  # PostgreSQL数据库
  postgres:
    image: postgres:14
    container_name: notification-db
    environment:
      POSTGRES_DB: notification_db
      POSTGRES_USER: notification_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - notification-network

  # Redis缓存和消息队列
  redis:
    image: redis:7-alpine
    container_name: notification-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - notification-network

  # RabbitMQ消息队列
  rabbitmq:
    image: rabbitmq:3.11-management
    container_name: notification-rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    ports:
      - "5672:5672"
      - "15672:15672"   # 管理界面
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - notification-network

  # FastAPI应用
  api:
    build:
      context: .
      dockerfile: docker/Dockerfile
    container_name: notification-api
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      - ./app:/app
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://notification_user:${DB_PASSWORD}@postgres:5432/notification_db
      - REDIS_URL=redis://redis:6379/0
      - RABBITMQ_URL=amqp://admin:${RABBITMQ_PASSWORD}@rabbitmq:5672/
    depends_on:
      - postgres
      - redis
      - rabbitmq
    networks:
      - notification-network

  # Celery Worker
  celery-worker:
    build:
      context: .
      dockerfile: docker/Dockerfile
    container_name: notification-worker
    command: celery -A app.tasks worker --loglevel=info --concurrency=4
    volumes:
      - ./app:/app
    environment:
      - DATABASE_URL=postgresql://notification_user:${DB_PASSWORD}@postgres:5432/notification_db
      - REDIS_URL=redis://redis:6379/0
      - RABBITMQ_URL=amqp://admin:${RABBITMQ_PASSWORD}@rabbitmq:5672/
    depends_on:
      - postgres
      - redis
      - rabbitmq
    networks:
      - notification-network

  # Celery Beat (定时任务调度器)
  celery-beat:
    build:
      context: .
      dockerfile: docker/Dockerfile
    container_name: notification-beat
    command: celery -A app.tasks beat --loglevel=info
    volumes:
      - ./app:/app
    environment:
      - DATABASE_URL=postgresql://notification_user:${DB_PASSWORD}@postgres:5432/notification_db
      - REDIS_URL=redis://redis:6379/0
      - RABBITMQ_URL=amqp://admin:${RABBITMQ_PASSWORD}@rabbitmq:5672/
    depends_on:
      - postgres
      - redis
      - rabbitmq
    networks:
      - notification-network

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:

networks:
  notification-network:
    driver: bridge
```

#### 3.5.2 环境变量配置

**.env文件示例**：
```env
# ==================== 数据库配置 ====================
DATABASE_URL=postgresql://notification_user:your_password@postgres:5432/notification_db
DB_POOL_SIZE=5
DB_MAX_OVERFLOW=15
DB_POOL_TIMEOUT=30
DB_POOL_RECYCLE=3600

# ==================== Redis配置 ====================
REDIS_URL=redis://redis:6379/0
REDIS_MAX_CONNECTIONS=50

# ==================== RabbitMQ配置 ====================
RABBITMQ_URL=amqp://admin:your_rabbitmq_password@rabbitmq:5672/
RABBITMQ_PREFETCH_COUNT=10

# ==================== 应用配置 ====================
APP_NAME=notification-platform
APP_VERSION=1.0.0
SECRET_KEY=your-secret-key-at-least-32-chars-long
DEBUG=false
LOG_LEVEL=INFO
ALLOWED_HOSTS=*

# ==================== JWT配置 ====================
JWT_SECRET_KEY=your-jwt-secret-key-at-least-32-chars
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=60

# ==================== 加密配置 ====================
ENCRYPTION_KEY=your-encryption-key-base64-encoded

# ==================== SMTP配置 ====================
EMAIL_TIMEOUT=30
EMAIL_MAX_SIZE=20971520  # 20MB

# ==================== 附件配置 ====================
ATTACHMENT_STORAGE_PATH=/data/attachments
ATTACHMENT_MAX_SIZE=10485760  # 10MB
ATTACHMENT_EXPIRE_DAYS=7

# ==================== Celery配置 ====================
CELERY_BROKER_URL=amqp://admin:your_rabbitmq_password@rabbitmq:5672/
CELERY_RESULT_BACKEND=redis://redis:6379/1
CELERY_WORKER_CONCURRENCY=4
CELERY_TASK_TIME_LIMIT=300

# ==================== 其他 ====================
TZ=Asia/Shanghai
PYTHONUNBUFFERED=1
```

### 3.6 错误码定义

| 错误码 | 说明 | HTTP状态码 |
|--------|------|-----------|
| 0 | 成功 | 200 |
| 1001 | 请求参数错误 | 400 |
| 1002 | 认证失败（Token无效或过期） | 401 |
| 1003 | 权限不足 | 403 |
| 1004 | 资源不存在 | 404 |
| 1005 | 请求方法不允许 | 405 |
| 1006 | 重复请求（幂等键重复） | 409 |
| 2001 | 邮件发送失败 | 500 |
| 2002 | 邮箱池无可用账户 | 503 |
| 2003 | 模板不存在或已删除 | 404 |
| 2004 | 模板渲染失败（变量缺失或格式错误） | 400 |
| 2005 | 附件上传失败 | 500 |
| 2006 | 附件不存在或已过期 | 404 |
| 2007 | 附件大小超过限制 | 413 |
| 2008 | 消息不存在 | 404 |
| 2009 | SMTP连接失败 | 502 |
| 3001 | 数据库连接失败 | 500 |
| 3002 | Redis连接失败 | 500 |
| 3003 | 消息队列错误 | 500 |
| 5000 | 系统内部错误 | 500 |
| 5001 | 服务暂时不可用 | 503 |

**错误响应格式示例**：
```json
{
    "code": 2004,
    "message": "模板渲染失败：缺少必需变量 'username'",
    "data": null,
    "request_id": "req_xyz789",
    "timestamp": "2025-10-24T10:00:00Z"
}
```

---

## 4. 第二期（功能增强）详细需求

### 4.1 功能需求概述

#### 4.1.1 微信消息发送功能
- 集成个人微信消息发送能力（通过第三方工具如itchat或wxpy）
- 支持发送文本、图片、文件消息
- 注意：个人微信接口不稳定，需做好风险提示

#### 4.1.2 微信公众号消息发送功能
- 集成微信公众号模板消息接口
- 支持自定义模板消息内容
- 支持公众号模板管理

#### 4.1.3 定时/延迟发送功能
- 支持指定未来时间发送消息
- 支持延迟N分钟/小时/天发送
- 使用Celery的定时任务实现

#### 4.1.4 管理后台界面
- 提供Web管理后台
- 功能包括：
  - 消息发送历史查看
  - 消息统计图表
  - 模板管理
  - 邮箱池管理
  - 短信配置管理
  - 系统配置管理

#### 4.1.5 短信多渠道支持
- 支持腾讯云短信、华为云短信
- 支持主备切换和容灾
- 某个渠道失败时自动切换到备用渠道

#### 4.1.6 消息统计分析功能
- 按日期统计发送数量
- 按渠道统计发送成功率
- 按模板统计使用次数
- 提供可视化图表

### 4.2 接口需求

#### 4.2.1 定时发送接口
**接口地址**：`POST /api/v1/messages/email/send/scheduled`

**请求参数**：
```json
{
    // ... 邮件发送的基本参数
    "scheduled_time": "2025-10-25 10:00:00"  // 定时发送时间
}
```

#### 4.2.2 微信消息发送接口
**接口地址**：`POST /api/v1/messages/wechat/send`

**请求参数**：
```json
{
    "to_user": "微信用户ID或备注名",
    "message_type": "text",              // text/image/file
    "content": "消息内容",
    "file_path": ""                      // 文件类型时提供
}
```

#### 4.2.3 微信公众号消息发送接口
**接口地址**：`POST /api/v1/messages/wechat-mp/send`

**请求参数**：
```json
{
    "openid": "用户OpenID",
    "template_id": "模板ID",
    "data": {
        "first": {"value": "标题", "color": "#173177"},
        "keyword1": {"value": "内容1", "color": "#173177"},
        "keyword2": {"value": "内容2", "color": "#173177"},
        "remark": {"value": "备注", "color": "#173177"}
    },
    "url": "点击跳转URL"
}
```

#### 4.2.4 消息统计接口
**接口地址**：`GET /api/v1/statistics/summary`

**查询参数**：
- `start_date`: 开始日期
- `end_date`: 结束日期
- `message_type`: 消息类型（可选）

**响应示例**：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "total_sent": 10000,
        "success_count": 9800,
        "failed_count": 200,
        "success_rate": 0.98,
        "by_type": {
            "email": {"total": 5000, "success": 4900, "failed": 100},
            "sms": {"total": 5000, "success": 4900, "failed": 100}
        },
        "by_date": [
            {"date": "2025-10-20", "total": 2000, "success": 1960},
            {"date": "2025-10-21", "total": 2000, "success": 1960}
        ]
    }
}
```

### 4.3 数据库扩展

**定时任务表 (scheduled_tasks)**
```sql
CREATE TABLE scheduled_tasks (
    id BIGSERIAL PRIMARY KEY,
    task_id VARCHAR(64) UNIQUE NOT NULL,              -- 任务ID
    message_id BIGINT NOT NULL,                       -- 关联的消息ID
    scheduled_time TIMESTAMP NOT NULL,                -- 定时发送时间
    status VARCHAR(20) DEFAULT 'pending',             -- pending/executed/cancelled
    executed_at TIMESTAMP,                            -- 实际执行时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_scheduled_time (scheduled_time),
    INDEX idx_status (status)
);
```

**微信配置表 (wechat_configs)**
```sql
CREATE TABLE wechat_configs (
    id BIGSERIAL PRIMARY KEY,
    config_type VARCHAR(20) NOT NULL,                 -- personal/mp (个人微信/公众号)
    app_id VARCHAR(100),                              -- 公众号AppID
    app_secret VARCHAR(255),                          -- 公众号AppSecret（加密）
    access_token TEXT,                                -- 访问令牌
    token_expire_at TIMESTAMP,                        -- 令牌过期时间
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 5. 第三期（高级特性）详细需求

### 5.1 功能需求概述

#### 5.1.1 API限流和防刷机制
- 基于IP的限流（每IP每分钟最多100次请求）
- 基于API Key的限流（根据不同等级设置不同限额）
- 防止恶意刷接口
- 超过限制返回429状态码

#### 5.1.2 监控告警功能
- 集成Prometheus + Grafana监控
- 监控指标：
  - API请求量、响应时间
  - 消息发送成功率
  - 队列堆积情况
  - 数据库连接池状态
  - 系统资源使用率
- 告警策略：
  - 发送失败率超过5%触发告警
  - 队列堆积超过1000条触发告警
  - API响应时间P95超过500ms触发告警
  - 数据库连接池使用率超过80%触发告警

#### 5.1.3 系统性能优化
- 接口性能优化，P95响应时间 < 100ms
- 数据库查询优化，添加索引
- 消息发送并发优化
- 缓存优化，减少数据库查询

#### 5.1.4 多租户支持
- 支持多个租户接入
- 租户隔离（数据隔离、配置隔离）
- 租户配额管理
- 租户统计分析

#### 5.1.5 API Key管理
- 支持创建、更新、删除API Key
- 支持设置API Key的权限和配额
- 支持API Key的过期时间设置
- 提供API Key使用统计

#### 5.1.6 消息批量发送接口
- 支持批量发送邮件（最多100个收件人）
- 支持批量发送短信
- 批量发送异步处理

#### 5.1.7 Webhook回调机制
- 消息发送成功/失败后回调客户端提供的URL
- 支持配置回调URL和回调认证
- 重试机制：回调失败最多重试3次

### 5.2 数据库扩展

**租户表 (tenants)**
```sql
CREATE TABLE tenants (
    id BIGSERIAL PRIMARY KEY,
    tenant_name VARCHAR(100) UNIQUE NOT NULL,
    tenant_key VARCHAR(64) UNIQUE NOT NULL,           -- 租户唯一标识
    status VARCHAR(20) DEFAULT 'active',              -- active/suspended/closed
    email_quota INT DEFAULT 10000,                    -- 邮件配额/月
    sms_quota INT DEFAULT 5000,                       -- 短信配额/月
    current_email_usage INT DEFAULT 0,
    current_sms_usage INT DEFAULT 0,
    quota_reset_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Webhook配置表 (webhook_configs)**
```sql
CREATE TABLE webhook_configs (
    id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL,
    callback_url VARCHAR(500) NOT NULL,
    events JSONB NOT NULL,                            -- 订阅的事件类型
    auth_type VARCHAR(20),                            -- 认证类型: none/bearer/basic
    auth_token VARCHAR(255),                          -- 认证令牌
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 6. 示例用例（第一期）

### 6.1 完整的使用流程

#### 步骤1：获取JWT Token
```bash
curl -X POST "http://localhost:8000/api/v1/auth/token" \
  -H "Content-Type: application/json" \
  -d '{
    "api_key": "noti_abc123def456",
    "api_secret": "your_api_secret"
  }'
```

**响应**：
```json
{
  "code": 0,
  "data": {
    "access_token": "eyJhbGc...",
    "token_type": "bearer",
    "expires_in": 3600
  }
}
```

#### 步骤2：上传附件（如果需要）
```bash
curl -X POST "http://localhost:8000/api/v1/attachments/upload" \
  -H "Authorization: Bearer eyJhbGc..." \
  -F "file=@/path/to/report.pdf"
```

**响应**：
```json
{
  "code": 0,
  "data": [{
    "attachment_id": "att_20251024_abc123",
    "filename": "report.pdf",
    "file_size": 1024000
  }]
}
```

#### 步骤3：发送邮件
```bash
curl -X POST "http://localhost:8000/api/v1/messages/email/send" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "to": "user@example.com",
    "subject": "月度报告",
    "content": "<h1>这是您的月度报告</h1>",
    "attachment_ids": ["att_20251024_abc123"],
    "idempotency_key": "report_202510_user123"
  }'
```

**响应**：
```json
{
  "code": 0,
  "data": {
    "message_id": "msg_20251024_def456",
    "status": "pending"
  }
}
```

#### 步骤4：查询发送状态
```bash
curl -X GET "http://localhost:8000/api/v1/messages/msg_20251024_def456" \
  -H "Authorization: Bearer eyJhbGc..."
```

**响应**：
```json
{
  "code": 0,
  "data": {
    "message_id": "msg_20251024_def456",
    "status": "success",
    "sent_at": "2025-10-24 10:00:05"
  }
}
```

### 6.2 邮件发送场景示例

**场景1：发送简单的HTML邮件**
```bash
curl -X POST "http://localhost:8000/api/v1/messages/email/send" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "to": "user@example.com",
    "subject": "欢迎注册",
    "content": "<div style=\"font-family: Arial, sans-serif;\"><h2>欢迎加入我们！</h2><p>感谢您的注册。</p></div>",
    "content_type": "html"
  }'
```

**场景2：使用模板发送验证码邮件**
```bash
curl -X POST "http://localhost:8000/api/v1/messages/email/send" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "to": "user@example.com",
    "template_id": 1,
    "template_vars": {
      "username": "张三",
      "code": "123456",
      "expire_minutes": "5"
    },
    "idempotency_key": "verify_user123_20251024"
  }'
```

**场景3：发送带附件的邮件**
```bash
# 先上传附件
curl -X POST "http://localhost:8000/api/v1/attachments/upload" \
  -H "Authorization: Bearer eyJhbGc..." \
  -F "file=@contract.pdf"

# 发送邮件
curl -X POST "http://localhost:8000/api/v1/messages/email/send" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "to": "client@example.com",
    "cc": ["manager@example.com"],
    "subject": "合同文件",
    "content": "<p>您好，请查收合同文件。</p>",
    "attachment_ids": ["att_20251024_abc123"]
  }'
```

**场景4：批量发送（通过多次调用）**
```bash
# 方式1：循环调用API（适合不同内容）
for email in user1@example.com user2@example.com user3@example.com; do
  curl -X POST "http://localhost:8000/api/v1/messages/email/send" \
    -H "Authorization: Bearer eyJhbGc..." \
    -H "Content-Type: application/json" \
    -d "{
      \"to\": \"$email\",
      \"template_id\": 1,
      \"template_vars\": {\"username\": \"用户\", \"code\": \"123456\"}
    }"
done

# 方式2：使用BCC（适合相同内容）
curl -X POST "http://localhost:8000/api/v1/messages/email/send" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "to": "noreply@example.com",
    "bcc": ["user1@example.com", "user2@example.com", "user3@example.com"],
    "subject": "系统通知",
    "content": "<p>这是一条系统通知</p>"
  }'
```

### 6.3 模板管理示例

**创建邮件模板**
```bash
curl -X POST "http://localhost:8000/api/v1/templates" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "template_name": "注册验证码",
    "template_type": "email",
    "subject": "【验证码】{{username}}，您的验证码",
    "content": "<div style=\"font-family: Arial, sans-serif; padding: 20px;\"><h2>尊敬的{{username}}，您好！</h2><p>您的验证码是：<strong style=\"color: #ff6600; font-size: 24px;\">{{code}}</strong></p><p>验证码有效期为{{expire_minutes}}分钟，请及时使用。</p><p style=\"color: #999; font-size: 12px;\">如果这不是您的操作，请忽略此邮件。</p></div>",
    "variables": ["username", "code", "expire_minutes"],
    "description": "用户注册时发送的验证码邮件",
    "created_by": "admin"
  }'
```

**预览模板效果**
```bash
curl -X POST "http://localhost:8000/api/v1/templates/preview" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "template_id": 1,
    "template_vars": {
      "username": "张三",
      "code": "123456",
      "expire_minutes": "5"
    }
  }'
```

**更新模板**
```bash
curl -X PUT "http://localhost:8000/api/v1/templates/1" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "subject": "【重要】{{username}}，您的验证码",
    "change_description": "在主题中添加重要标识",
    "updated_by": "admin"
  }'
```

**查看模板历史版本**
```bash
curl -X GET "http://localhost:8000/api/v1/templates/1/history" \
  -H "Authorization: Bearer eyJhbGc..."
```

**回滚模板到旧版本**
```bash
curl -X POST "http://localhost:8000/api/v1/templates/1/rollback" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "version": 1,
    "change_description": "回滚到初始版本",
    "updated_by": "admin"
  }'
```

### 6.4 消息查询示例

**查询单个消息**
```bash
curl -X GET "http://localhost:8000/api/v1/messages/msg_20251024_abc123" \
  -H "Authorization: Bearer eyJhbGc..."
```

**批量查询消息**
```bash
curl -X POST "http://localhost:8000/api/v1/messages/batch/query" \
  -H "Authorization: Bearer eyJhbGc..." \
  -H "Content-Type: application/json" \
  -d '{
    "message_ids": ["msg_20251024_abc123", "msg_20251024_abc124"]
  }'
```

**按条件查询历史消息**
```bash
curl -X GET "http://localhost:8000/api/v1/messages?recipient=user@example.com&status=success&page=1&page_size=20" \
  -H "Authorization: Bearer eyJhbGc..."
```

### 6.5 系统健康检查示例

**简单健康检查**
```bash
curl -X GET "http://localhost:8000/health"
```

**就绪检查（含依赖服务状态）**
```bash
curl -X GET "http://localhost:8000/health/ready"
```

**Prometheus监控指标**
```bash
curl -X GET "http://localhost:8000/metrics"
```

---

## 7. 开发计划

### 7.1 第一期开发计划（2周）

> **第一期目标**：聚焦邮件通知功能，快速验证系统架构可行性

#### **第1周：基础框架和核心功能**

**Day 1-2：项目初始化**
- ✅ 搭建项目框架（FastAPI + SQLAlchemy）
- ✅ 配置开发环境和代码规范（Black、Pylint）
- ✅ 配置Docker Compose环境（PostgreSQL、Redis、RabbitMQ）
- ✅ 初始化数据库（创建表、触发器、索引）
- ✅ 配置Alembic数据库迁移工具

**Day 3-4：邮件发送核心功能**
- ✅ 实现邮箱池管理模块
  - 邮箱账户CRUD
  - 邮箱选择算法（优先级+发送数量）
  - 日发送计数重置机制
  - 失败计数和自动禁用
- ✅ 实现SMTP邮件发送功能
  - 支持HTML/文本邮件
  - 支持CC/BCC
  - SMTP连接池管理
- ✅ 单元测试（邮箱池逻辑）

**Day 5：消息队列集成**
- ✅ 配置Celery + RabbitMQ
- ✅ 实现异步邮件发送任务
- ✅ 实现消息入队和消费
- ✅ 配置Flower监控

#### **第2周：完善功能和发布**

**Day 1-2：模板和附件**
- ✅ 实现消息模板管理
  - 模板CRUD接口
  - Jinja2模板渲染
  - 模板版本管理和历史记录
- ✅ 实现附件管理
  - 附件上传接口
  - 本地文件存储
  - 附件过期清理（Celery定时任务）

**Day 3-4：认证、去重和重试**
- ✅ 实现JWT认证
  - API Key管理
  - Token生成和验证
  - Token刷新机制
- ✅ 实现消息去重机制
  - 幂等键去重
  - 内容指纹去重（Redis）
- ✅ 实现失败重试机制
  - 重试策略（指数退避）
  - 重试队列和死信队列
  - 重试日志记录

**Day 5：监控、测试和文档**
- ✅ 实现基础监控
  - 健康检查接口（/health, /health/ready）
  - Prometheus指标暴露（/metrics）
  - 日志规范实施
- ✅ 编写单元测试和集成测试
  - 核心功能测试覆盖率达到60%+
- ✅ 生成Swagger API文档
- ✅ 编写部署文档
- ✅ Docker镜像构建和测试部署

#### **验收检查清单**

在第一期结束前，确保以下功能全部可用：
- [ ] Docker环境一键启动
- [ ] 邮件发送功能正常（含邮箱池轮询）
- [ ] 模板管理功能完整（CRUD+版本管理）
- [ ] 附件上传和发送正常
- [ ] JWT认证机制工作正常
- [ ] 消息去重功能有效
- [ ] 失败重试机制正常
- [ ] 健康检查接口响应正常
- [ ] Prometheus指标正常暴露
- [ ] API文档完整且可访问
- [ ] 单元测试通过率100%
- [ ] 压力测试达到50并发，P95<200ms

### 7.2 第二期开发计划（3-4周）

**第1-2周**：
- 实现微信消息和公众号消息发送
- 实现定时/延迟发送功能
- 实现短信多渠道支持

**第3-4周**：
- 开发管理后台界面
- 实现消息统计分析功能
- 完善文档和测试

### 7.3 第三期开发计划（2-3周）

**第1周**：
- 实现API限流和防刷
- 实现监控告警
- 性能优化

**第2-3周**：
- 实现多租户支持
- 实现Webhook回调
- 实现批量发送
- 压力测试和优化

---

## 8. 风险评估与应对

### 8.1 技术风险

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 个人微信接口不稳定 | 高 | 提供企业微信作为替代方案，做好风险提示 |
| 邮箱被封禁 | 中 | 邮箱池设计，支持快速切换；建议使用企业邮箱 |
| 第三方服务商API变更 | 中 | 抽象第三方服务接口，便于切换 |
| 消息队列堆积 | 中 | 监控队列长度，动态调整消费者数量 |

### 8.2 业务风险

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 短信成本过高 | 中 | 实施发送频率限制，提供配额管理 |
| 垃圾邮件投诉 | 高 | 实施发送频率限制，提供退订机制（二期） |
| 数据泄露 | 高 | 加密存储敏感信息，实施访问控制 |

---

## 9. 验收标准

### 9.1 第一期验收标准

#### 功能验收
- [ ] **环境部署**
  - Docker Compose一键启动所有服务
  - 所有服务健康检查通过
  - 数据库表和触发器创建成功

- [ ] **邮件发送功能**
  - 支持HTML和文本格式邮件
  - 支持CC/BCC
  - 邮箱池轮询和自动切换正常
  - 邮箱日发送计数自动重置
  - 连续失败3次自动禁用邮箱
  - 异步发送正常，消息入队成功

- [ ] **附件功能**
  - 附件上传成功，返回attachment_id
  - 发送带附件的邮件成功
  - 单个附件不超过10MB限制生效
  - 附件7天后自动清理

- [ ] **模板管理**
  - 模板CRUD操作正常
  - Jinja2模板渲染正确
  - 模板变量替换成功
  - 模板版本管理和历史记录正常
  - 模板回滚功能可用
  - 模板预览功能正常

- [ ] **消息去重**
  - 幂等键去重生效（5分钟内重复请求返回缓存结果）
  - 内容指纹去重生效
  
- [ ] **失败重试**
  - 发送失败自动重试（最多3次）
  - 重试间隔符合预期（1分钟、5分钟、10分钟）
  - 重试日志记录完整
  - 最终失败消息进入死信队列

- [ ] **认证和鉴权**
  - API Key创建成功
  - JWT Token获取成功
  - Token过期后需要重新获取
  - Token刷新机制正常
  - 未认证请求返回401

- [ ] **消息查询**
  - 单个消息查询正常
  - 批量查询正常
  - 历史记录查询和分页正常
  - 查询条件筛选生效

- [ ] **监控和健康检查**
  - /health接口返回200
  - /health/ready检查所有依赖服务
  - /metrics暴露Prometheus指标
  - Flower监控Celery任务正常

#### 性能验收
- [ ] API接口响应时间P95 < 200ms（不含实际发送）
- [ ] 消息入队时间 < 100ms
- [ ] 支持50个并发请求
- [ ] 邮件发送吞吐量 ≥ 100封/分钟

#### 质量验收
- [ ] 单元测试覆盖率 ≥ 60%
- [ ] 所有单元测试通过
- [ ] 核心功能集成测试通过
- [ ] 代码符合PEP8规范
- [ ] 无Critical级别的安全漏洞

#### 文档验收
- [ ] API文档完整（Swagger自动生成）
- [ ] 所有接口有示例
- [ ] 部署文档完整可执行
- [ ] README文件完整
- [ ] 数据库设计文档完整

### 9.2 第二期验收标准

- [ ] 定时/延迟发送功能可用
- [ ] 微信消息/公众号消息发送可用
- [ ] 管理后台界面可用
- [ ] 短信多渠道支持和切换可用
- [ ] 消息统计分析功能可用

### 9.3 第三期验收标准

- [ ] API限流机制正常工作
- [ ] 监控告警系统部署完成
- [ ] 多租户功能可用
- [ ] Webhook回调功能可用
- [ ] 性能优化后P95响应时间<100ms
- [ ] 压力测试通过：支持200并发

---

## 10. 附录

### 10.1 推荐的Python库

**Web框架**：
- FastAPI：高性能Web框架
- uvicorn：ASGI服务器

**数据库**：
- SQLAlchemy：ORM框架
- psycopg2-binary：PostgreSQL驱动
- alembic：数据库迁移工具

**消息队列**：
- celery：分布式任务队列
- redis：缓存和消息队列
- pika：RabbitMQ客户端

**邮件和短信**：
- aiosmtplib：异步SMTP客户端
- aliyun-python-sdk-dysmsapi：阿里云短信SDK

**其他**：
- pydantic：数据验证
- python-jose：JWT认证
- cryptography：加密库
- httpx：HTTP客户端

### 10.2 开发环境配置

**requirements.txt**（第一期需要的库）：
```
# ==================== Web框架 ====================
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# ==================== 数据库 ====================
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
alembic==1.12.1

# ==================== 消息队列和任务调度 ====================
celery==5.3.4
redis==5.0.1
flower==2.0.1

# ==================== 数据验证 ====================
pydantic==2.5.0
pydantic-settings==2.1.0
email-validator==2.1.0

# ==================== 认证和安全 ====================
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
cryptography==41.0.7

# ==================== 邮件发送 ====================
aiosmtplib==3.0.1

# ==================== 模板引擎 ====================
jinja2==3.1.2

# ==================== HTTP客户端 ====================
httpx==0.25.2

# ==================== 日志 ====================
loguru==0.7.2

# ==================== 监控 ====================
prometheus-client==0.19.0

# ==================== 工具库 ====================
python-dateutil==2.8.2

# ==================== 测试 ====================
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
pytest-mock==3.12.0
httpx-mock==0.13.0

# ==================== 代码质量 ====================
black==23.12.1
flake8==7.0.0
pylint==3.0.3
mypy==1.7.1
```

**requirements-dev.txt**（开发环境额外需要的库）：
```
# 开发工具
ipython==8.18.1
ipdb==0.13.13

# API测试
httpie==3.2.2

# 文档生成
mkdocs==1.5.3
mkdocs-material==9.5.3
```

**安装方式**：
```bash
# 生产环境
pip install -r requirements.txt

# 开发环境
pip install -r requirements.txt -r requirements-dev.txt
```

### 10.3 相关文档链接

- FastAPI官方文档：https://fastapi.tiangolo.com/
- SQLAlchemy文档：https://docs.sqlalchemy.org/
- Celery文档：https://docs.celeryq.dev/
- 阿里云短信服务文档：https://help.aliyun.com/product/44282.html
- PostgreSQL文档：https://www.postgresql.org/docs/

---

---

## 附录A：更新日志

### v1.1 - 2025-10-24

**重大调整**：
- ✅ **第一期范围调整**：聚焦邮件通知单一渠道，移除短信、微信功能至第二期
- ✅ **开发周期优化**：第一期从2-3周缩短为2周

**新增功能**：
- ✅ 消息去重机制（幂等键+内容指纹）
- ✅ 邮件附件管理功能（独立上传接口）
- ✅ JWT Token认证机制（替代原API Key方案）
- ✅ 基础监控指标暴露（Prometheus格式）
- ✅ 健康检查接口（/health, /health/ready, /health/live）
- ✅ 模板版本管理和历史记录
- ✅ 模板预览功能
- ✅ 消息批量查询接口

**数据库设计优化**：
- ✅ 添加外键约束
- ✅ 添加数据库触发器（邮箱计数自动重置）
- ✅ 添加字段注释（COMMENT）
- ✅ 新增`message_template_history`表（模板历史）
- ✅ 新增`email_attachments`表（附件管理）
- ✅ `message_records`表添加字段：
  - `template_version`（模板版本号）
  - `retry_logs`（重试日志）
  - `idempotency_key`（幂等键）
  - `request_id`（请求追踪ID）
- ✅ `email_accounts`表添加字段：
  - `failure_count`（连续失败次数）
  - `last_failure_at`（最后失败时间）
- ✅ `api_keys`表优化：
  - `api_secret_hash`（bcrypt哈希，不存储明文）
  - `last_used_at`（最后使用时间）
  - `usage_count`（使用次数）

**接口设计完善**：
- ✅ 明确邮件发送接口的两种模式（直接发送/模板发送）
- ✅ 参数互斥校验规则
- ✅ 添加附件上传接口
- ✅ 添加模板预览接口
- ✅ 添加模板版本管理接口（历史查询、回滚）
- ✅ 添加消息批量查询接口
- ✅ 完善错误码定义（增加HTTP状态码映射）

**安全性增强**：
- ✅ 详细的加密方案说明（AES-256-GCM）
- ✅ JWT认证流程完善
- ✅ 敏感信息脱敏规范
- ✅ API Secret使用bcrypt哈希存储

**可维护性提升**：
- ✅ 详细的日志规范（JSON格式、级别使用、脱敏规则）
- ✅ Request ID全链路追踪
- ✅ 完整的环境变量配置清单
- ✅ 代码规范说明（Black、Pylint）
- ✅ 测试策略补充

**文档完善**：
- ✅ 更详细的开发计划（按天拆分任务）
- ✅ 完整的示例用例（包含完整使用流程）
- ✅ 详细的验收标准（功能、性能、质量、文档）
- ✅ 完整的requirements.txt（分类清晰）

**删除内容**：
- ❌ 第一期移除短信发送功能（移至第二期）
- ❌ 第一期移除微信消息功能（移至第二期）
- ❌ `sms_configs`表（移至第二期）
- ❌ `sms_templates`表（移至第二期）

---

### v1.0 - 2025-10-24

- 初始版本发布
- 定义项目目标和范围
- 三期需求规划
- 基础功能需求定义
- 数据库设计
- 接口设计
- 部署方案

---

## 文档结束

本需求文档由需求分析师编写，当前版本v1.1。文档将根据项目进展和需求变更持续更新。

**重要提示**：
- 第一期聚焦邮件通知功能，确保快速验证架构可行性
- 短信、微信等渠道将在第二期实现
- 所有最高优先级问题已在本次修订中解决

如有任何疑问或需要补充的内容，请及时反馈。

**下一步行动**：
1. 与技术团队评审修订后的需求文档
2. 生成配套文档（开发规范、数据库设计文档、API接口文档）
3. 开始第一期开发工作

